;; ============================================
;; 고차 함수 예제
;; ============================================

;; 1. map - 리스트의 각 요소에 함수 적용
(define numbers (list 1 2 3 4 5))

;; 각 요소를 제곱
(define (square x) (* x x))
(map square numbers)

;; 각 요소를 2배
(define (double x) (* 2 x))
(map double numbers)

;; 2. filter - 조건을 만족하는 요소만 필터링
(define (even? x) (= (remainder x 2) 0))
(filter even? numbers)

;; 5보다 큰 수만 필터링
(define (greater-than-5 x) (> x 5))
(filter greater-than-5 (list 3 6 2 8 1 9))

;; 3. fold/reduce - 리스트를 하나의 값으로 축약
(define (add x y) (+ x y))
(fold add 0 numbers)

;; 곱하기로 축약
(define (multiply x y) (* x y))
(fold multiply 1 numbers)

;; 4. 커스텀 고차 함수 - 리스트의 모든 요소에 함수 적용 후 합
(define (map-then-sum f lst)
  (fold add 0 (map f lst)))

(map-then-sum square numbers)
(map-then-sum double numbers)

;; 5. 커스텀 고차 함수 - 두 리스트를 결합
(define (zip-with f lst1 lst2)
  (if (or (null? lst1) (null? lst2))
      (list)
      (cons (f (car lst1) (car lst2))
            (zip-with f (cdr lst1) (cdr lst2)))))

(zip-with + (list 1 2 3) (list 4 5 6))
(zip-with * (list 2 3 4) (list 5 6 7))

;; 6. 함수 합성
(define (compose f g)
  (lambda (x)
    (f (g x))))

(define add-one (lambda (x) (+ x 1)))
(define multiply-two (lambda (x) (* x 2)))

(define add-one-then-double (compose multiply-two add-one))
(add-one-then-double 5)

;; 7. 부분 적용 (currying)
(define (make-adder n)
  (lambda (x)
    (+ x n)))

(define add-five (make-adder 5))
(add-five 10)

(define add-ten (make-adder 10))
(add-ten 20)

;; 8. 리스트의 모든 요소가 조건을 만족하는지 확인
(define (all? pred lst)
  (if (null? lst)
      #t
      (if (pred (car lst))
          (all? pred (cdr lst))
          #f)))

(all? even? (list 2 4 6 8))
(all? even? (list 2 4 5 8))

;; 9. 리스트의 어떤 요소라도 조건을 만족하는지 확인
(define (any? pred lst)
  (if (null? lst)
      #f
      (if (pred (car lst))
          #t
          (any? pred (cdr lst)))))

(any? even? (list 1 3 5 7))
(any? even? (list 1 3 4 7))

;; 10. 리스트의 각 요소를 변환하는 고차 함수
(define (transform-list f lst)
  (if (null? lst)
      (list)
      (cons (f (car lst))
            (transform-list f (cdr lst)))))

(transform-list square (list 1 2 3 4))

;; 11. apply - 함수에 인자 리스트 적용
(apply + (list 1 2 3 4 5))
(apply max (list 3 7 2 9 1))

;; 12. let을 사용한 지역 변수와 고차 함수
(let ((numbers (list 1 2 3 4 5))
      (square (lambda (x) (* x x))))
  (map square numbers))
